//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.0;

import "hardhat/console.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "./ISavingsModule.sol";
import "./CurveFiProtocol_Y.sol";
import "./IUniswapV2Pair.sol";
import "./IPoolToken_CurveFi_Y.sol";

contract somename {
    address stor0;
    address stor1;
    uint stor2;
    uint stor3;
    address stor4;
    //address stor5; // savings module:
    ISavingsModule savingsModule = ISavingsModule(0x73fC3038B4cD8FfD07482b92a52Ea806505e5748);
    address stor6; // dydx contract: 0x1e0447b19bb6ecfdae1e4ae1694b0c3659614e4e
    //address stor7; // dai contract: 0x6b175474e89094c44da98b954eedeac495271d0f
    ERC20 dai = ERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F); 

    // not sure if they set these in the constructore or the a/b/w methods
    somefunction(uint _number, address _protocol, uint _value) {
        //stor0 = _protocol; We know it is CurveFiProtocol_Y
        CurveFiProtocol_Y stor0 = CurveFiProtocol_Y(0x91d7b9a8d2314110d4018c88dbfdcf5e2ba4772e);
        stor3 = _value;

        // calls this:
        address stor1Address = ISavingsModule.poolTokenByProtocol(protocol);
        IPoolToken_CurveFi_Y stor1 = IPoolToken_CurveFi_Y(0x2afa3c8bf33e65d5036cd0f1c3599716894b3077);

        // if calling CurveFiProtocol_SUSD
        if(stor0 == 0x91d7b9a8d2314110d4018c88dbfdcf5e2ba4772e) {
            // uint256(stor2.field_0) = 800000 * 10^18
            // seems to set 
            stor2 = 800000*10**18;
            // approves DAI on akro:
            dai.approve(address(savingsModule), uint(-1));
            uint daiBalance = dai.balanceOf(address(this));
            // roughly line 58 on bytecode
            if(daiBalance > stor2){
                // does a while loop of while id (from 0) is less than _value
                // is this the several calls we see inthe tx?

                // calls something on ISavingsModule (line 94)
                // then calls 
                uint nBalance = stor0.normalizedBalance(); // (line 102)
                // I think above is _1429 and below is _1469 or/and _1487
                uint poolTokenBalance = stor1.balanceOf(address(this));

                if(nBalance > poolTokenBalance) {

                    if(poolTokenBalance == 0) { // if not mem[_1469]:
                        // calls a savings module withdraw with 0 values:
                        ISavingsModule.withdraw(address(stor0), address(dai), 0, 0);
                    
                    } else { // line 173
                        uint foo = 99 * poolTokenBalance/100;
                        ISavingsModule.withdraw(address(stor0), address(dai), foo, 0);

                    }


                } else {
                    // if not _1429: ??
                    if(nBalance == 0) {
                        ISavingsModule.withdraw(address(stor0), address(dai), 0, 0);
                    // if 99 * _1429 / _1429 != 99: WTF?
                    } else {
                        uint bar = 99 * nBalance/100;
                        ISavingsModule.withdraw(address(stor0), address(dai), bar, 0);
                    }
                   
                }

                // } increment while loop and back to the top.

                // here on line 191 they remove the approval.
            }  else { //line 201

                // here they approve the dydx contract for spending max dai

                // shit gets weird, and then they remove approval of dydx/dai
            
                // then they remove approval of SavingsModule/dai
            }
            

        } else {
            
            // line 408 they call 
            uint poolTokenBalance = stor1.balanceOf(address(this));
            stor2 = -poolTokenBalance + 50000 * 10^18 / 2; // line 421
            dai.approve(address(savingsModule), uint(-1));
            uint daiBalance = dai.balanceOf(address(this));
            if(daiBalance > stor2) {
                // back to the while loop.

            }      

        }
    }





}