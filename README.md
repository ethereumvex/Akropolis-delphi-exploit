# Akropolis Delphi Exploit

## Summary

- On November 12th, 2020, an attacker exploited a chain of vulnerabilities in the [Akropolis SavingsModule](https://github.com/akropolisio/delphi/blob/release-1.0/contracts/modules/savings/SavingsModule.sol) contract.
- Over the course of several transactions they were able to extract more than 2 million `dai` from their pools.

## Background

The Akropolis Delphi project was created to allow users an easy interface into underlying DeFi protocols like [Curve.fi](http://curve.fi). Users were rewarded Delphi governance tokens for doing so, and some innovative features were to be added to the platform.

The deposit interface constrained users to depositing the appropriate tokens for the underlying protocols; unfortunately the underlying `SavingsModule` contract itself did not enforce this check. By interacting directly with the contract, a user could deposit *any* token to the system in exchange for the underlying pool tokens. 

A second vulnerability existed where `SavingsModule` contract was open to re-entrance via `depositToProtocol`. Given that this method calls a token's `transferFrom` method, theoretically a token contract could re-enter `SavingsModule`. With these two vulnerabilities, a malicious user could create a fake token with a malicious transferFrom method.

## This repository

The repository is a Hardhat based re-construction of one example of the exploit. To use it, clone the repository and then install the dependencies with `npm install`. Rename the `.env-sample` file to `.env` and paste in your `Alchemyapi url`. Running `npx hardhat run scripts/deploy.js` from the root will execute a transaction similar to that of the exploiter. This transaction is run against a forked `mainnet` version uses Hardhat's Solidity `console.log` to print results of the process to the console. A proper `test` setup is still in progress.

## Details of the vulnerability

The `deposit` method on the `SavingsModule` contract is used to deposit funds into an underlying strategy via `depositToProtocol`, after which pool tokens are minted and returned to the depositor. Prior to calling `depositToProtocol` there are no obvious checks performed on the parameters; no whitelisting of accepted tokens or otherwise. There is one early call that *could* perform a check, `normalizeTokenAmount`, however as we will see further below this method performs no checks and made some questionable assumptions. The `deposit` code below has been simplified and some comments added (see the [original code here](https://github.com/akropolisio/delphi/blob/release-1.0/contracts/modules/savings/SavingsModule.sol#L217-L277)):

```jsx
function deposit(address _protocol, address[] memory _tokens, uint256[] memory _dnAmounts)
    public operationAllowed(IAccessModule.Operation.Deposit)
    returns(uint256) 
    {

        uint256 nAmount;
        for (uint256 i=0; i < _tokens.length; i++) {
						// normalizeTokenAmount might have been a place to check the token validity
            nAmount = nAmount.add(normalizeTokenAmount(_tokens[i], _dnAmounts[i]));
        }
				
        uint256 nBalanceBefore = distributeYieldInternal(_protocol);
				// depositToProtocol calls transferFrom which will allow re-entry
				depositToProtocol(_protocol, _tokens, _dnAmounts);
        uint256 nBalanceAfter = updateProtocolBalance(_protocol);
				
        PoolToken poolToken = PoolToken(protocols[_protocol].poolToken);
        
				uint256 nDeposit = nBalanceAfter.sub(nBalanceBefore);

        uint256 cap;
        if(userCapEnabled) {
            cap = userCap(_protocol, _msgSender());
        }

				// pool tokens are minted here. Both cases are used in the exploit
        uint256 fee;
        if(nAmount > nDeposit) {
            fee = nAmount - nDeposit;
            poolToken.mint(_msgSender(), nDeposit);
        } else {
            fee = 0;
            poolToken.mint(_msgSender(), nAmount);
            uint256 yield = nDeposit - nAmount;
            if (yield > 0) {
                createYieldDistribution(poolToken, yield);
            }
        }

        emit Deposit(_protocol, _msgSender(), nAmount, fee);
        return nDeposit;
    }
```

The following method is where the re-entrance is possible (see comment):

```jsx
function depositToProtocol(address _protocol, address[] memory _tokens, uint256[] memory _dnAmounts) internal {
        require(_tokens.length == _dnAmounts.length, "SavingsModule: count of tokens does not match count of amounts");
        for (uint256 i=0; i < _tokens.length; i++) {
            address tkn = _tokens[i];
						// safeTransferFrom is called on the token that was passed in by the user.
            IERC20(tkn).safeTransferFrom(_msgSender(), _protocol, _dnAmounts[i]);
            IDefiProtocol(_protocol).handleDeposit(tkn, _dnAmounts[i]);
            emit DepositToken(_protocol, tkn, _dnAmounts[i]);
        }
    }
```

Excluding other possibilities, `normalizeTokenAmount` is where a check using `mapping(address => TokenData) tokens;` could have  reverted any unlisted tokens. See comments in the code:

```jsx
function normalizeTokenAmount(address token, uint256 amount) private view returns(uint256) {
        // tokens is a mapping that could have served as a sanity check on the 
				// address token parameter, asserting that the token was present:
				uint256 decimals = tokens[token].decimals;
        // below, a dangerous assumption whereby if there is no record of the token
				// in the mapping, the final "else if" is used as the condition is true: tokens
				// not in the tokens mapping return 0 for tokens[token].decimals. 
				if (decimals == 18) {
            return amount;
        } else if (decimals > 18) {
            return amount.div(10**(decimals-18));
        } else if (decimals < 18) {
            return amount.mul(10**(18 - decimals));
        }
 }
```

It is often the case that a few small bugs or conditions chained together can become a major issue. In this exploit a re-entrance opportunity spotted by a malicious actor would encourage them to dig deeper. It just so happens that the lack of a token sanity check meant that the system would accept a token with a malicious `transferFrom` method, and in this case result in minting more pool tokens than actual value moved into the system. 

## Details of the exploit

Examining the bytecode of the [contract](https://etherscan.io/address/0xe2307837524db8961c4541f943598654240bd62f) published by the [exploiter](https://etherscan.io/address/0x9f26ae5cd245bfeeb5926d61497550f79d9c6c1c) showed that they had a few different methods they used, for example `a()` [here](https://etherscan.io/tx/0x4ec646d40205bb9caf92f86da911350abd764de51e154fce2771ea431020091c) and `b()` [here](https://etherscan.io/tx/0xd143af3180c4e0ca060394bfb0e5ea3070246aed98e25dd1681a6a1c76b683d0). But the main method seemed to be `0x02908e5f` (see transaction below), which decompiled to a long complex construction. 

The first seven storage slots provided some clues to help deduce what the attacker was doing in `0x02908e5f`, but the most simple manner to see what was happening was using [https://oko.palkeo.com/](https://oko.palkeo.com/) on [this transaction](https://oko.palkeo.com/0xe2307837524Db8961C4541f943598654240bd62f/calls_from/), where, along with some event logs, you could follow the different actions undertaken by the code. Looking at that last link you can pull out a central process that gets looped thru a few times:

1. Call `savingsModule.poolTokenByProtocol`
2. Call `balanceOf` on `dyPoolToken` 
3. Approve spending of contract's `dai` by `savingsModule`
4. Check balance of `dai`
5. Call `savingsModule.deposit` sending `5000000` of `address(this)` (the fake token).
6. Re-entered into `address(this).transferFrom` and calls `savingsModule.deposit` again, this time to deposit real `dai`.
7. Transfer `1 dai` to the Akropolis `curveYPool`.
8. Call `savingsModule.normalizedBalance`.
9. Call `balanceOf` on `dyPoolToken`.
10. Call `savingsModule.withdraw` for less pool tokens than they actually have.
11. `Approve` `0 dai`.

This process is the one undertaken in this repository and it was able to withdraw roughly `23,000 dai` per loop after paying back the flash loan. 

There are some inconsistencies in the system that I was not able to deduce and that the hacker appeared to understand. For some reason you could not withdraw by sending all of your pool tokens to `savingsModule.withdraw`; indeed, as a Delphi user I was not able to send all of my tokens to their interface either. The exploiter has a calculation that you can see in the bytecode whereby they would withdraw `99%` of their pool token balance rather than `100%`. 

While rebuilding the exploit it was also interesting to see that you could send fake tokens to the contract and have the `address(this).transferFrom` return `true`, and then withdrawing your resulting tokens you could actually get `dai` out of the system.

It is worth noting that the code in the exploits removed the `dai` `approval` to `SavingsModule` after each loop; looking at the timeline below, the contract held the `dai` until they were finished exploiting, and then they moved the `dai` to their wallet.

## Timeline of events

- [Nov-12-2020 11:47:44 AM +UTC](https://etherscan.io/tx/0x431af3fbce70dbc880f24d62f5dcecea7fa79becf16495563c7cbd283ca8a853) [the exploiter](https://etherscan.io/address/0x9f26ae5cd245bfeeb5926d61497550f79d9c6c1c) publishes the [malicious contract](https://etherscan.io/address/0xe2307837524db8961c4541f943598654240bd62f) to mainnet.
- During the next hour they proceed to run [26 more transactions](https://etherscan.io/txs?a=0x9f26ae5cd245bfeeb5926d61497550f79d9c6c1c), some of which ran out of gas; the contract provides a view of the [results of the transactions](https://etherscan.io/tokentxns?a=0xe2307837524db8961c4541f943598654240bd62f).
- [Nov-12-2020 12:04:41 PM +UTC](https://etherscan.io/tx/0xf15623567231c67df2b8bcc5540236fbda2c3ac11ecbec427048f11b582cb869), less than 20 minutes after publishing the contract, the exploiter transfers `2,030,850 dai` from the contract to their wallet.